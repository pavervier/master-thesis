/**
 * Final-year project, University of Li√®ge
 * Automated analysis and detection of spamming botnets.
 * 
 * @author  Pierre-Antoine Vervier
 * @version May, 2010
 * 
 * This class implements a SMTP client signature generator.
 * 
 * When a SMTP session sample is first collected, a SessionFingerPrint instance
 * is asked to extract a fingerprint for the session. The session is then put in
 * an appropriate SessionCluster according to the fingerprint. Finally, a
 * signature can be generated from the set of SMTP session samples stored in a
 * given cluster. The signature is composed of TCP/SMTP/IMF regular expression
 * statements which are then used to match further instances of SMTP sessions
 * comming from the same client.
 * 
 */

package be.ulg.vervier.SmtpDump.BotsSignature.SignatureGeneration;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.GregorianCalendar;
import be.ulg.vervier.SmtpDump.SMTPSessionManagement.SMTPSession;
import be.ulg.vervier.SmtpDump.SMTPSessionManagement.SessionStatement;
import be.ulg.vervier.SmtpDump.SMTPSessionManagement.SessionStatementType;
import be.ulg.vervier.SmtpDump.SMTPSessionManagement.SMTPCommand;
import be.ulg.vervier.SmtpDump.SMTPSessionManagement.IMFMessage;
import be.ulg.vervier.SmtpDump.SMTPSessionManagement.IMFStatement;
import be.ulg.vervier.SmtpDump.BotsSignature.Signature;
import be.ulg.vervier.SmtpDump.BotsSignature.SignatureMatcher;
import be.ulg.vervier.SmtpDump.BotsSignature.InvalidBotSignatureException;
import java.util.logging.Logger;
import java.util.logging.Level;
import java.util.logging.FileHandler;

public class SignatureGenerator {
    
    /** INSTANCE VARIABLES */
    
    /** The SMTP session samples pools: a collection of SessionCluster */
    private Map<SessionFingerPrint, SessionCluster> samples;
    /** The number of SMTP session samples required to generate a signature
     * from a cluster. */
    private static int sig_gen_sample;
    /** True to enable automatic signature generation when session clusters
     * reach 'SIG_GEN_SAMPLE' samples, false otherwise */
    private boolean auto_generate;
    /** The signature matcher to which generated signatures have to be
     * exported */
    private SignatureMatcher sig_container;
    /** The base number for the generated signatures (initialized with current
     * timespam) */
    private long sig_name_base;
    /** The generated signature output file name */
    private String sig_out_filename;
    /** The number of signatures generated so far. */
    private int sig_gen_count;
    /** The signature file writer */
    private SignatureFileWriter sig_file_writer;
    /** Logger: log SMTPDUMP program error */
    private static final Logger LOGGER =
        Logger.getLogger(be.ulg.vervier.SmtpDump.SmtpDumpMain.class.getName());
    
    /** CONSTRUCTORS */
    
    /** Default constructor. */
    public SignatureGenerator() { this(null, null, false); }
    
    /** Create a new signature generator linked with the given signature
     * matcher, the signature output file name and the automatic signature
     * generation enabled/disabled. */
    public SignatureGenerator(SignatureMatcher sig_matcher,
							  String sig_out_filename,
							  boolean auto_generate) {
        this(sig_matcher, sig_out_filename, false, 50);
    }
    
    /** Create a new signature generator linked with the given signature
     * matcher, the signature output file name, the automatic signature
     * generation enabled/disabled and the given signature generation sample
     * number. */
    public SignatureGenerator(SignatureMatcher sig_matcher,
							  String sig_out_filename,
							  boolean auto_generate,
							  int sig_gen_sample) {
        samples = new HashMap<SessionFingerPrint, SessionCluster>();
        this.sig_container = sig_matcher;
        this.sig_out_filename = sig_out_filename;
        this.sig_file_writer = null;
        this.sig_gen_sample = sig_gen_sample;
        this.auto_generate = auto_generate;
        this.sig_name_base = new GregorianCalendar().getTimeInMillis();
        sig_gen_count = 0;
    }
    
    /** METHODS */
    
    /** Enable/disable the automatic signature generation.
     * When enabled, signatures are generated automatically when session
     * clusters reach 'SIG_GEN_SAMPLE' samples. When disabled, signatures can be
     * generated by calling 'generateSignatures'.
     * */
    public void autoGenerate(boolean auto_generate) {
        this.auto_generate = auto_generate;
    }
    
    /** Add the given SMTP session to the collector. */
    public void addSampleSession(SMTPSession session) {
        if (session == null || sig_gen_sample <= 0) return;
        SessionFingerPrint sfp = new SessionFingerPrint();
        sfp.fingerPrint(session);
        SessionCluster sc;
        if (!samples.containsKey(sfp)) {
            sc = new SessionCluster();
            sc.addSession(session);
            samples.put(sfp, sc);
            //System.out.println("NEW FINGERPRINT:" + session);
        } else {
            (sc = samples.get(sfp)).addSession(session);
        }
        if (auto_generate && checkSigGenSample(sc))
            generateSignatures();
    }
    
    /** Generate signatures from clusters storing at least 'SIG_GEN_SAMPLE' SMTP
     * session samples. */
    public void generateSignatures() {
		if (sig_gen_sample <= 0) return;
        SessionCluster sc = null;
        ArrayList<TreeBuilder> l_tb = new ArrayList<TreeBuilder>();
        LinkedList<Integer> imf_messages = new LinkedList<Integer>();
        //l_tb.add(new TreeBuilder());    // TEMP
        PhylogeneticTree t = null;
        for (Iterator<SessionCluster> it = samples.values().iterator();
			it.hasNext();) {
            if (checkSigGenSample(sc = it.next())) {
				// build the phylogenetic trees for the different SMTP commands
				// and IMF messages found in the cluster of sessions
				// (this operation allows the multiple alignment)
                for (SMTPSession session: sc.getSessions()) {
                    int i = 0;
                    for (SessionStatement st: session.getCommands()) {
                        if (i == l_tb.size())
                            l_tb.add(new TreeBuilder());
                        if (st.stmtType() == SessionStatementType.COMMAND) {
                            l_tb.get(i).
								addSequence(((SMTPCommand)st).command());
                        } else if
							(st.stmtType() == SessionStatementType.MESSAGE) {
                            l_tb.get(i).
								addSequence(((IMFMessage)st).message());
                            imf_messages.add(i);
                        }
                        i++;
                    }
                }
                // build the signature
                if (sig_file_writer == null) {
					sig_file_writer = new SignatureFileWriter();
					try {
						sig_file_writer.openFile(sig_out_filename);
					} catch (SignatureFileWriterException sfwe) {
						LOGGER.severe("signature-generator:" +
									  sfwe.getMessage() + "\n");
					}
				}
                Signature gen_sig = new Signature("sig-" + sig_name_base++);
                try {
					sig_file_writer.openNewSignature(gen_sig.getIdentifier());
                    int i = 0;
                    for (TreeBuilder tb: l_tb) {
                        // build the regular expression for that SMTP statement
                        traverseTreeForAlignment
							((t = tb.buildTree()).getRoot());
                        String regex = buildRegex(t);
                        if (regex != null) {
							gen_sig.addSignatureRegex
								(regex, null, false, false);
							try {
                                // check if it is a IMF message or a
                                // SMTP command
                                if (imf_messages.peekFirst() != null &&
                                    imf_messages.peekFirst() == i) {
                                    imf_messages.pollFirst();
                                    sig_file_writer.writeIMFStatement(regex);
                                } else {
                                    sig_file_writer.writeSMTPStatement(regex);
                                }
							} catch (SignatureFileWriterException sfwe) {
								LOGGER.severe("signature-generator:" +
											  sfwe.getMessage() + "\n");
							}
						}
                        i++;
                    }
                } catch (InvalidBotSignatureException ibse) {
                    LOGGER.warning("signature-generator:invalid regex\n");
				} catch (SignatureFileWriterException sfwe) {
					LOGGER.severe("signature-generator:" +
								  sfwe.getMessage() + "\n");
				}
                if (sc.getSessionCount() > 0) {
					SMTPSession session = sc.getSessions().get(0);
					// record TCP flags
					try {
						if (session.hasTcpSyn()) {
							gen_sig.checkTcpSyn();
							sig_file_writer.writeTCPOpen();
						}
						if (session.hasTcpFin()) {
							gen_sig.checkTcpFin();
							sig_file_writer.writeTCPClose();
						}
						if (session.hasTcpRst()) {
							gen_sig.checkTcpRst();
							sig_file_writer.writeTCPReset();
						}
						if (!gen_sig.isEmpty()) {
                            // add the signature to the signature matcher pool
							sig_container.addSignature(gen_sig);
                            // write it to the file
							sig_file_writer.endSignature();
                            sig_gen_count++;
						}
					} catch (SignatureFileWriterException sfwe) {
						LOGGER.severe("signature-generator:" +
								  sfwe.getMessage() + "\n");
					}
				}
                it.remove();
            }
        }
    }
    
    /** Close the signature file. */
    public void closeSignatureFile() {
		if (sig_file_writer != null) {
			try {
				sig_file_writer.closeFile();
			} catch (SignatureFileWriterException sfwe) {
				LOGGER.severe("signature-generator:" +
								  sfwe.getMessage() + "\n");
			}
		}
	}
    
    /** Retrieve the number of signatures generated so far. */
    public int getGeneratedSigCount() { return sig_gen_count; }
    
    /** Retrieve the current number of sample clusters. */
    public int getClusterCount() {
        return samples == null ? 0 : samples.size();
    }
    
    /** Retrieve the generated signatures output file name. */
    public String getSignatureFileName() {
        return sig_out_filename == null ? "" : sig_out_filename;
    }
    
    /** Perform a post order traversal of the phylogenetic tree rooted at the
     * given node to perform the multiple sequence alignment on the set of
     * sequences stored in the tree. */
    private void traverseTreeForAlignment(TreeNode n) {
        if (n == null || (n != null && n.isLeaf())) return;
        // visit left child first
        traverseTreeForAlignment(n.getLeftChild());
        // visit right child
        traverseTreeForAlignment(n.getRightChild());
        // perform the sequence alignment on the sequences from the children
        SequenceAlignment sa = new SequenceAlignment();
        sa.alignNW(n.getLeftChild().getValue(), n.getRightChild().getValue());
        n.getLeftChild().addGaps(sa.getFirstSequenceGaps());
        n.getRightChild().addGaps(sa.getSecondSequenceGaps());
        // the sequence with the least number of gaps becomes the representative
        if (sa.getFirstSequenceGaps().size() <=
			sa.getSecondSequenceGaps().size())
            n.setValue(n.getLeftChild().getValue());
        else
            n.setValue(n.getRightChild().getValue());
    }
    
    /** Generate the regular expression for the given phylogenetic tree. This
     * must be done after the mulitple sequence alignment operation has been
     * performed. */
    private String buildRegex(PhylogeneticTree t) {
        if (t == null) return null;
        LinkedList<AlignedSequence> als = new LinkedList<AlignedSequence>();
        traverseTreeForRegex(t.getRoot(), als);
        StringBuilder regex = new StringBuilder();
        int longuest_sequence = -1;
        for (AlignedSequence as: als)
			if (as.length() > longuest_sequence)
				longuest_sequence = as.length();
		Character cur_char, prev_char = null;
		int cons_gap_count = 0;
		int cons_diff_count = 0;
		// build a regular expression
		for (int i = 0; i < longuest_sequence; i++) {
			cur_char = prev_char = null;
			// test all characters at one position
			for (AlignedSequence as: als) {
				cur_char = as.getCharAt(i);
				if (cur_char == null) {
					cons_gap_count++;
					if (i == longuest_sequence - 1)
						regex.append(".{").
							  append(cons_diff_count).
							  append(",").
							  append((cons_diff_count + cons_gap_count)).
							  append("}");
					break;
				} else if (prev_char != null && !cur_char.equals(prev_char)) {
					cons_diff_count++;
					if (i == longuest_sequence - 1)
						regex.append(".{").
							  append(cons_diff_count).
							  append(",").
							  append((cons_diff_count + cons_gap_count)).
							  append("}");
					cur_char = null;
					break;
				}
				prev_char = cur_char;
			}
			// all characters at one position are equal
			if (cur_char != null) {
				// write buffer gaps and diffs
				if (cons_gap_count > 0 && cons_diff_count > 0)
					regex.append(".{").
						  append(cons_diff_count).
						  append(",").
						  append((cons_diff_count + cons_gap_count)).
						  append("}");
				else if (cons_gap_count > 0 && cons_diff_count == 0)
					regex.append(".{0,").
						  append(cons_gap_count).
						  append("}");
				else if (cons_diff_count > 0 && cons_gap_count == 0)
					regex.append(".{").
						  append(cons_diff_count).
						  append("}");
				// write character
				regex.append(escapeMetaCharacter(cur_char.charValue()));
				cons_gap_count = 0;
				cons_diff_count = 0;
			}
		}
        return regex.toString();
    }
    
    /** Escape the given regular expression character if necessary. */
    private String escapeMetaCharacter(char c) {
        switch (c) {
            case '(': return "\\(";
            case ')': return "\\(";
            case '\\': return "\\\\";
            case '+': return "\\+";
            case '*': return "\\*";
            case '?': return "\\?";
            case '[': return "\\[";
            case ']': return "\\]";
            case '.': return "\\.";
            case '{': return "\\{";
            case '}': return "\\}";
            case '$': return "\\$";
            case '^': return "\\^";
            case '\t': return "\\t";
            case '\r': return "\\r";
            case '\n': return "\\n";
            default: break;
        }
        return new StringBuilder(1).append(c).toString();
    }
    
    /** Perform a postorder traversal of the phylogenetic tree rooted at the
     * given node to build a regular expression resulting from the multiple
     * sequence alignement operation on the tree. */
    private void traverseTreeForRegex(TreeNode n, List<AlignedSequence> als) {
        if (n == null || als == null) return;
        if (!n.isRoot()) {
			// retrieve the gaps from the parent node to complete current node
			// gaps according the multiple alignment
			n.addGaps(n.getParent().getGaps());
		}
        if (n.hasLeftChild())
            traverseTreeForRegex(n.getLeftChild(), als);
        if (n.hasRightChild())
            traverseTreeForRegex(n.getRightChild(), als);
        // build an aligned sequence using the original sequence and the gaps
        // to apply according the multiple alignment
        if (n.isLeaf()) {
			Collections.sort(n.getGaps());
			AlignedSequence as = new AlignedSequence();
			as.setAlignedSequence(n.getValue(), n.getGaps());
			als.add(as);
		}
    }
    
    /** Return true if the given session cluster stores enough sessions samples
     * for a signature to be generated, according to 'SIG_GEN_SAMPLE' value,
     * false otherwise. */
    private boolean checkSigGenSample(SessionCluster sc) {
        return sc != null && sc.getSessionCount() >= sig_gen_sample;
    }
    
}
